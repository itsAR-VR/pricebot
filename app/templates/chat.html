{% extends "base.html" %}
{% block content %}
<div id="chat-root" class="chat-root" aria-live="polite"></div>

<style>
  :root {
    color-scheme: dark;
  }

  .chat-root {
    display: flex;
    flex-direction: column;
    height: calc(100vh - 140px);
    max-height: 820px;
    gap: 16px;
  }

  .chat-shell {
    flex: 1;
    display: flex;
    flex-direction: column;
    border-radius: 16px;
    background: rgba(10, 22, 39, 0.65);
    border: 1px solid rgba(77, 96, 130, 0.35);
    box-shadow: 0 18px 38px rgba(12, 35, 56, 0.35);
    overflow: hidden;
  }

  .chat-header {
    padding: 18px 22px 14px 22px;
    border-bottom: 1px solid rgba(77, 96, 130, 0.25);
    display: flex;
    flex-direction: column;
    gap: 14px;
    background: rgba(13, 29, 52, 0.88);
  }

  .chat-header h1 {
    margin: 0;
    font-size: 20px;
    font-weight: 600;
  }

  .chat-header p {
    margin: 0;
    color: rgba(226, 232, 240, 0.75);
    font-size: 14px;
  }

  .chat-header-top {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 16px;
  }

  .diagnostics-btn {
    border-radius: 12px;
    border: 1px solid rgba(148, 163, 184, 0.3);
    background: rgba(15, 23, 42, 0.65);
    color: rgba(226, 232, 240, 0.9);
    font-size: 13px;
    padding: 10px 14px;
    cursor: pointer;
    transition: border-color 0.2s ease, transform 0.2s ease;
  }

  .diagnostics-btn:hover {
    border-color: rgba(148, 163, 184, 0.55);
    transform: translateY(-1px);
  }

  .status-pill {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    border-radius: 999px;
    padding: 4px 10px;
    font-size: 12px;
    background: rgba(56, 189, 248, 0.12);
    color: #38bdf8;
  }

  .chat-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
  }

  .chat-action-btn {
    border-radius: 12px;
    border: 1px solid rgba(148, 163, 184, 0.2);
    background: rgba(30, 41, 59, 0.6);
    color: rgba(226, 232, 240, 0.86);
    font-size: 13px;
    padding: 10px 14px;
    cursor: pointer;
    transition: border-color 0.2s ease, transform 0.2s ease;
  }

  .chat-action-btn:hover {
    border-color: rgba(148, 163, 184, 0.5);
    transform: translateY(-1px);
  }

  .transcript {
    flex: 1;
    overflow-y: auto;
    padding: 22px 26px;
    display: flex;
    flex-direction: column;
    gap: 18px;
    background: linear-gradient(180deg, rgba(15, 23, 42, 0.62) 0%, rgba(8, 15, 30, 0.82) 100%);
  }

  .composer {
    padding: 18px 22px;
    border-top: 1px solid rgba(77, 96, 130, 0.25);
    background: rgba(13, 29, 52, 0.92);
    display: flex;
    flex-direction: column;
    gap: 12px;
    position: relative;
  }

  .composer textarea {
    resize: none;
    min-height: 72px;
    border-radius: 14px;
    border: 1px solid rgba(148, 163, 184, 0.25);
    background: rgba(15, 23, 42, 0.78);
    color: rgba(226, 232, 240, 0.95);
    padding: 14px 16px;
    font-size: 15px;
    line-height: 1.4;
  }

  .composer textarea:focus {
    outline: none;
    border-color: rgba(56, 189, 248, 0.55);
    box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.35);
  }

  .composer-controls {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .composer-controls button {
    border-radius: 12px;
    border: none;
    background: linear-gradient(135deg, rgba(56, 189, 248, 1) 0%, rgba(14, 165, 233, 1) 100%);
    color: #0b1120;
    font-weight: 600;
    font-size: 15px;
    padding: 12px 20px;
    cursor: pointer;
    box-shadow: 0 10px 24px rgba(56, 189, 248, 0.35);
  }

  .composer-controls button:disabled {
    opacity: 0.55;
    cursor: not-allowed;
    box-shadow: none;
  }

  .control-ghost {
    border-radius: 12px;
    border: 1px dashed rgba(148, 163, 184, 0.4);
    background: rgba(15, 23, 42, 0.5);
    color: rgba(226, 232, 240, 0.8);
    font-size: 13px;
    padding: 10px 12px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 8px;
  }

  .control-ghost:hover {
    border-color: rgba(148, 163, 184, 0.65);
  }

  .toggle-control {
    user-select: none;
  }

  .toggle-control input {
    width: 16px;
    height: 16px;
    accent-color: #38bdf8;
  }

  .attachment-tray {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    padding: 10px 4px 0 4px;
  }

  .attachment-pill {
    position: relative;
    border-radius: 12px;
    border: 1px solid rgba(148, 163, 184, 0.35);
    background: rgba(30, 41, 59, 0.75);
    color: rgba(226, 232, 240, 0.95);
    padding: 10px 12px 10px 42px;
    min-width: 180px;
  }

  .attachment-pill img {
    position: absolute;
    top: 8px;
    left: 8px;
    width: 26px;
    height: 26px;
    border-radius: 6px;
    object-fit: cover;
    border: 1px solid rgba(148, 163, 184, 0.4);
  }

  .attachment-pill .remove {
    position: absolute;
    top: 6px;
    right: 6px;
    background: rgba(15, 23, 42, 0.85);
    border: 1px solid rgba(100, 116, 139, 0.6);
    border-radius: 50%;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: rgba(248, 250, 252, 0.85);
    cursor: pointer;
    font-size: 12px;
  }

  .message-bubble {
    max-width: 640px;
    border-radius: 20px;
    padding: 16px 20px;
    font-size: 15px;
    line-height: 1.5;
    background: rgba(22, 33, 52, 0.9);
    border: 1px solid rgba(148, 163, 184, 0.16);
    box-shadow: 0 16px 36px rgba(8, 24, 48, 0.4);
    position: relative;
  }

  .message-user {
    align-self: flex-end;
    background: linear-gradient(135deg, rgba(56, 189, 248, 0.2) 0%, rgba(125, 211, 252, 0.15) 100%);
    border-color: rgba(125, 211, 252, 0.45);
  }

  .message-metadata {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
    color: rgba(148, 163, 184, 0.78);
    margin-bottom: 10px;
  }

  .message-attachments {
    display: flex;
    flex-direction: column;
    gap: 6px;
    margin-top: 12px;
  }

  .message-attachments span {
    font-size: 13px;
    color: rgba(226, 232, 240, 0.75);
  }

  .offer-card {
    display: grid;
    gap: 14px;
    border-radius: 16px;
    border: 1px solid rgba(148, 163, 184, 0.18);
    background: rgba(13, 24, 45, 0.85);
    padding: 18px;
  }

  .offer-header {
    display: flex;
    gap: 18px;
  }

  .offer-header img {
    width: 126px;
    height: 126px;
    border-radius: 12px;
    object-fit: cover;
    border: 1px solid rgba(148, 163, 184, 0.25);
    background: rgba(15, 23, 42, 0.6);
  }

  .offer-title {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .offer-title h3 {
    margin: 0;
    font-size: 18px;
  }

  .offer-title ul {
    list-style: none;
    margin: 0;
    padding: 0;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    font-size: 13px;
    color: rgba(148, 163, 184, 0.86);
  }

  .best-offer {
    display: grid;
    gap: 10px;
    border-radius: 14px;
    padding: 14px;
    background: rgba(22, 163, 74, 0.12);
    border: 1px solid rgba(74, 222, 128, 0.25);
  }

  .offer-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 14px;
  }

  .alternate-list {
    display: grid;
    gap: 10px;
  }

  .alternate-item {
    display: grid;
    gap: 4px;
    padding: 12px 14px;
    border-radius: 12px;
    border: 1px solid rgba(148, 163, 184, 0.25);
    background: rgba(15, 23, 42, 0.6);
  }

  .vendor-row {
    display: flex;
    justify-content: space-between;
    font-size: 13px;
    color: rgba(226, 232, 240, 0.85);
  }

  .stepper {
    display: grid;
    gap: 10px;
    margin-top: 8px;
  }

  .step {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 14px;
    color: rgba(226, 232, 240, 0.78);
  }

  .step::before {
    content: '';
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: rgba(148, 163, 184, 0.45);
    flex-shrink: 0;
  }

  .step[data-status="active"]::before {
    background: #38bdf8;
    box-shadow: 0 0 0 4px rgba(56, 189, 248, 0.2);
  }

  .step[data-status="done"]::before {
    background: #22c55e;
  }

  .step[data-status="error"]::before {
    background: #f87171;
  }

  .error-banner {
    border-radius: 12px;
    border: 1px solid rgba(248, 113, 113, 0.45);
    background: rgba(220, 38, 38, 0.12);
    color: rgba(252, 231, 243, 0.95);
    padding: 12px 16px;
    font-size: 14px;
  }

  .vendor-input {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 12px 14px;
    border-radius: 12px;
    border: 1px dashed rgba(148, 163, 184, 0.35);
    background: rgba(15, 23, 42, 0.55);
  }

  .vendor-input input {
    border-radius: 10px;
    border: 1px solid rgba(148, 163, 184, 0.3);
    background: rgba(15, 23, 42, 0.65);
    color: rgba(226, 232, 240, 0.92);
    padding: 10px 12px;
    font-size: 14px;
  }

  .vendor-input input:focus {
    outline: none;
    border-color: rgba(56, 189, 248, 0.5);
  }

  .inline-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    border-radius: 999px;
    padding: 4px 10px;
    font-size: 12px;
    background: rgba(56, 189, 248, 0.14);
    color: rgba(125, 211, 252, 0.95);
  }

  .doc-chip {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    border-radius: 999px;
    padding: 6px 10px;
    font-size: 12px;
    background: rgba(148, 163, 184, 0.16);
    color: rgba(226, 232, 240, 0.9);
  }

  .mention-tray {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .mention-chip {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    border-radius: 999px;
    padding: 6px 10px;
    font-size: 12px;
    background: rgba(56, 189, 248, 0.16);
    color: rgba(226, 232, 240, 0.92);
    border: 1px solid rgba(56, 189, 248, 0.3);
  }

  .mention-chip[data-type="product"] {
    background: rgba(168, 85, 247, 0.16);
    border-color: rgba(168, 85, 247, 0.32);
    color: rgba(233, 213, 255, 0.92);
  }

  .mention-chip button {
    background: transparent;
    border: none;
    color: inherit;
    cursor: pointer;
    padding: 0 2px;
    line-height: 1;
  }

  .mention-chip button:focus-visible {
    outline: 1px solid currentColor;
    outline-offset: 2px;
  }

  .mention-helper {
    font-size: 12px;
    color: rgba(148, 163, 184, 0.78);
  }

  .mention-popover {
    position: absolute;
    z-index: 20;
    min-width: 220px;
    max-width: 320px;
    border-radius: 12px;
    border: 1px solid rgba(56, 189, 248, 0.38);
    background: rgba(13, 29, 52, 0.96);
    box-shadow: 0 12px 28px rgba(8, 24, 48, 0.45);
    display: flex;
    flex-direction: column;
    padding: 8px 0;
  }

  .mention-popover[hidden] {
    display: none;
  }

  .mention-popover-header {
    padding: 4px 14px 6px 14px;
    font-size: 12px;
    text-transform: uppercase;
    color: rgba(148, 163, 184, 0.78);
    letter-spacing: 0.06em;
  }

  .mention-option {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 2px;
    padding: 10px 14px;
    font-size: 13px;
    color: rgba(226, 232, 240, 0.94);
    background: transparent;
    border: none;
    width: 100%;
    text-align: left;
    cursor: pointer;
  }

  .mention-option[data-active="true"] {
    background: rgba(56, 189, 248, 0.18);
  }

  .mention-option span {
    font-size: 12px;
    color: rgba(148, 163, 184, 0.75);
  }

  .help-answer {
    display: grid;
    gap: 16px;
  }

  .help-sources {
    display: grid;
    gap: 12px;
  }

  .help-source {
    border-radius: 12px;
    border: 1px solid rgba(148, 163, 184, 0.2);
    background: rgba(30, 41, 59, 0.6);
    padding: 12px 16px;
    display: grid;
    gap: 6px;
  }

  .help-source h4 {
    margin: 0;
    font-size: 14px;
    color: rgba(226, 232, 240, 0.96);
  }

  .help-source small {
    font-size: 12px;
    color: rgba(148, 163, 184, 0.78);
  }

  .help-source p {
    margin: 0;
    font-size: 13px;
    color: rgba(203, 213, 225, 0.92);
  }

  .bundle-footer {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
    font-size: 12px;
    color: rgba(148, 163, 184, 0.75);
  }

  .recent-products {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 14px 16px;
    border-radius: 12px;
    border: 1px solid rgba(56, 189, 248, 0.18);
    background: rgba(15, 23, 42, 0.55);
  }

  .recent-products-title {
    margin: 0;
    font-size: 14px;
    font-weight: 600;
    color: rgba(226, 232, 240, 0.92);
  }

  .recent-products ul {
    margin: 0;
    padding-left: 16px;
    font-size: 13px;
    color: rgba(148, 163, 184, 0.85);
  }

  .empty-state {
    align-self: center;
    text-align: center;
    padding: 60px 40px;
    max-width: 380px;
    color: rgba(148, 163, 184, 0.8);
  }

  .drop-target {
    border: 2px dashed rgba(56, 189, 248, 0.55);
    background: rgba(14, 165, 233, 0.12);
  }

  .doc-summary {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 12px 14px;
    border-radius: 12px;
    border: 1px solid rgba(148, 163, 184, 0.25);
    background: rgba(15, 23, 42, 0.55);
  }

  .doc-summary-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 13px;
    color: rgba(226, 232, 240, 0.88);
  }

  .doc-summary-list {
    margin: 0;
    padding-left: 0;
    display: flex;
    flex-direction: column;
    gap: 6px;
    font-size: 13px;
    color: rgba(226, 232, 240, 0.82);
    list-style: none;
  }

  .doc-summary-empty {
    margin: 0;
    font-size: 13px;
    color: rgba(148, 163, 184, 0.75);
  }

  .diagnostics-section {
    display: flex;
    flex-direction: column;
    gap: 6px;
    padding: 12px 14px;
    border-radius: 12px;
    border: 1px solid rgba(148, 163, 184, 0.2);
    background: rgba(15, 23, 42, 0.5);
  }

  .diagnostics-section h3 {
    margin: 0;
    font-size: 13px;
    color: rgba(226, 232, 240, 0.88);
    text-transform: uppercase;
    letter-spacing: 0.04em;
  }

  .diagnostics-list {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .diagnostics-inline {
    display: flex;
    flex-direction: column;
    gap: 4px;
    font-size: 13px;
    color: rgba(226, 232, 240, 0.82);
  }

  .doc-offer-item {
    border-radius: 10px;
    border: 1px solid rgba(148, 163, 184, 0.25);
    background: rgba(11, 19, 33, 0.6);
    padding: 10px 12px;
    display: grid;
    gap: 4px;
  }

  .doc-offer-item.doc-offer-source-llm {
    border-color: rgba(56, 189, 248, 0.45);
    background: rgba(56, 189, 248, 0.12);
  }

  .doc-offer-item.doc-offer-source-heuristic {
    border-color: rgba(148, 163, 184, 0.35);
  }

  .doc-offer-title {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    font-weight: 600;
    color: rgba(226, 232, 240, 0.9);
  }

  .doc-offer-details {
    font-size: 12px;
    color: rgba(148, 163, 184, 0.85);
  }

  .doc-offer-badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 2px 8px;
    border-radius: 999px;
    font-size: 11px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.04em;
    background: rgba(148, 163, 184, 0.2);
    color: rgba(226, 232, 240, 0.92);
    white-space: nowrap;
  }

  .doc-offer-badge-llm {
    background: rgba(56, 189, 248, 0.18);
    color: #38bdf8;
  }

  .doc-offer-badge-heuristic {
    background: rgba(148, 163, 184, 0.25);
    color: rgba(226, 232, 240, 0.75);
  }

  .doc-summary-warning {
    border-radius: 12px;
    border: 1px solid rgba(252, 165, 165, 0.45);
    background: rgba(239, 68, 68, 0.14);
    padding: 12px 14px;
    font-size: 13px;
    color: rgba(254, 226, 226, 0.9);
    display: grid;
    gap: 6px;
  }

  .doc-summary-warning strong {
    color: rgba(254, 226, 226, 1);
  }

  @media (max-width: 900px) {
    .chat-shell {
      height: calc(100vh - 160px);
    }
    .chat-root {
      height: auto;
      max-height: none;
    }
  }
</style>

<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script>
  (function () {
    const config = {{ api_config | tojson }};
    const devMode = {{ dev_mode | tojson }};
    const environment = {{ environment | tojson }};
    const { useEffect, useMemo, useRef, useState } = React;

    function uid(prefix = "id") {
      return `${prefix}-${Math.random().toString(36).slice(2)}-${Date.now().toString(36)}`;
    }

    function formatCurrency(amount, currency) {
      try {
        return new Intl.NumberFormat("en-US", {
          style: "currency",
          currency: currency || "USD",
          maximumFractionDigits: 2,
        }).format(amount);
      } catch (_err) {
        return `${currency || "USD"} ${amount.toFixed(2)}`;
      }
    }

    function formatDate(isoString) {
      if (!isoString) return "";
      const date = new Date(isoString);
      if (Number.isNaN(date.getTime())) {
        return isoString;
      }
      return date.toLocaleString();
    }

    function relativeTime(isoString) {
      if (!isoString) return "";
      const date = new Date(isoString);
      if (Number.isNaN(date.getTime())) return "";
      const diffMs = Date.now() - date.getTime();
      const diffMinutes = Math.round(diffMs / 60000);
      if (diffMinutes < 1) return "just now";
      if (diffMinutes < 60) return `${diffMinutes} min ago`;
      const diffHours = Math.round(diffMinutes / 60);
      if (diffHours < 24) return `${diffHours} hr${diffHours === 1 ? "" : "s"} ago`;
      const diffDays = Math.round(diffHours / 24);
      return `${diffDays} day${diffDays === 1 ? "" : "s"} ago`;
    }

    function normalizeId(value) {
      if (value == null) return null;
      try {
        const text = String(value).trim();
        if (!text || text === "undefined" || text === "null") return null;
        return text;
      } catch (_err) {
        return null;
      }
    }

    function gatherSourceCandidates(metadata) {
      if (!metadata || typeof metadata !== "object") {
        return [];
      }
      const candidates = [];
      const directKeys = [
        "offer_sources",
        "offerSourceMap",
        "offer_lineage",
        "offerLineage",
        "offer_source_map",
        "normalization_sources",
        "normalizationSources",
        "sources",
        "lineage",
      ];
      directKeys.forEach((key) => {
        if (metadata[key]) {
          candidates.push(metadata[key]);
        }
      });
      const nestedKeys = [
        "normalization",
        "spreadsheet",
        "flags",
        "ingestion",
        "header_analysis",
        "analysis",
        "summary",
        "signals",
      ];
      nestedKeys.forEach((key) => {
        const value = metadata[key];
        if (value && typeof value === "object") {
          directKeys.forEach((innerKey) => {
            if (value[innerKey]) {
              candidates.push(value[innerKey]);
            }
          });
        }
      });
      return candidates;
    }

    function pickSourceFromCandidate(candidate, offerId, seen = new Set()) {
      if (!candidate) return null;
      const idStr = offerId;
      if (typeof candidate === "string") {
        const trimmed = candidate.trim();
        return trimmed || null;
      }
      if (Array.isArray(candidate)) {
        for (const item of candidate) {
          if (!item) continue;
          if (typeof item === "string") {
            if (/llm|heuristic|manual/i.test(item) && item !== idStr) {
              const trimmed = item.trim();
              if (trimmed) {
                return trimmed;
              }
            }
            continue;
          }
          if (typeof item === "object") {
            const hints = [
              item.source,
              item.origin,
              item.method,
              item.type,
            ].map((hint) => (typeof hint === "string" ? hint.trim() : null));
            const identifiers = [];
            if (item.id != null) identifiers.push(normalizeId(item.id));
            if (item.offer_id != null) identifiers.push(normalizeId(item.offer_id));
            if (item.offerId != null) identifiers.push(normalizeId(item.offerId));
            if (Array.isArray(item.ids)) {
              item.ids.forEach((value) => identifiers.push(normalizeId(value)));
            }
            const hasMatch = identifiers.filter(Boolean).includes(idStr);
            if (hasMatch) {
              const declaredSource =
                hints.find((hint) => hint) ||
                (Array.isArray(item.sources)
                  ? item.sources.find((value) => typeof value === "string" && value.trim())
                  : null);
              if (declaredSource) {
                return declaredSource;
              }
            }
          }
        }
        return null;
      }
      if (typeof candidate === "object") {
        if (seen.has(candidate)) {
          return null;
        }
        seen.add(candidate);
        if (candidate[idStr]) {
          const direct = candidate[idStr];
          if (typeof direct === "string") {
            const trimmed = direct.trim();
            if (trimmed) {
              return trimmed;
            }
          } else if (direct && typeof direct === "object") {
            const fromObject =
              (typeof direct.source === "string" && direct.source.trim()) ||
              (typeof direct.origin === "string" && direct.origin.trim()) ||
              (typeof direct.method === "string" && direct.method.trim());
            if (fromObject) {
              return fromObject;
            }
          }
        }
        for (const [key, value] of Object.entries(candidate)) {
          if (Array.isArray(value)) {
            const normalizedIds = value.map((entry) => normalizeId(entry)).filter(Boolean);
            if (normalizedIds.includes(idStr)) {
              const trimmedKey = key.trim();
              if (trimmedKey) {
                return trimmedKey;
              }
            }
          } else if (value && typeof value === "string") {
            if (normalizeId(key) === idStr) {
              const trimmedValue = value.trim();
              if (trimmedValue) {
                return trimmedValue;
              }
            }
          } else if (value && typeof value === "object") {
            const nested = pickSourceFromCandidate(value, idStr, seen);
            if (nested) {
              return nested;
            }
          }
        }
        seen.delete(candidate);
      }
      return null;
    }

    function resolveOfferSource(offer, metadata) {
      if (!offer) return null;
      const directHints = [
        offer.source,
        offer.origin,
        offer.normalization_source,
        offer.normalized_source,
      ];
      if (offer.payload && typeof offer.payload === "object") {
        directHints.push(offer.payload.source);
      }
      if (offer.raw_payload && typeof offer.raw_payload === "object") {
        directHints.push(offer.raw_payload.source);
      }
      if (offer.metadata && typeof offer.metadata === "object") {
        directHints.push(offer.metadata.source);
      }
      const hint = directHints.find((value) => typeof value === "string" && value.trim());
      if (hint) {
        return hint.trim();
      }
      const offerId = normalizeId(offer.id || offer.offer_id || offer.offerId);
      if (!offerId) {
        return null;
      }
      const candidates = gatherSourceCandidates(metadata);
      for (const candidate of candidates) {
        const resolved = pickSourceFromCandidate(candidate, offerId);
        if (resolved) {
          return resolved;
        }
      }
      return null;
    }

    const HEADER_WARNING_DEFAULT =
      "Column headers looked suspect — double-check that prices and quantities line up.";

    function collectMetadataObjects(metadata) {
      const results = [];
      if (!metadata || typeof metadata !== "object") {
        return results;
      }
      const queue = [metadata];
      const visited = new Set();
      while (queue.length) {
        const current = queue.shift();
        if (!current || typeof current !== "object" || visited.has(current)) {
          continue;
        }
        visited.add(current);
        results.push(current);
        const keys = [
          "flags",
          "normalization",
          "spreadsheet",
          "ingestion",
          "header_analysis",
          "analysis",
          "signals",
          "quality",
        ];
        keys.forEach((key) => {
          const value = current[key];
          if (value && typeof value === "object") {
            queue.push(value);
          }
        });
      }
      return results;
    }

    function extractHeaderWarnings(metadata, fileType) {
      const messages = [];
      if (!metadata || typeof metadata !== "object") {
        return messages;
      }
      const normalizedType = (fileType || "").toLowerCase();
      const processorHint = String(metadata.processor || metadata.ingestion_processor || "").toLowerCase();
      const likelySpreadsheet =
        /sheet|xls|xlsx|csv/.test(normalizedType) || /sheet|xls|xlsx|csv/.test(processorHint);

      const addMessage = (text) => {
        if (!text) return;
        const value = String(text).trim();
        if (!value) return;
        if (!messages.some((existing) => existing.toLowerCase() === value.toLowerCase())) {
          messages.push(value);
        }
      };

      const candidateObjects = collectMetadataObjects(metadata);
      candidateObjects.forEach((obj) => {
        if (!obj || typeof obj !== "object") return;
        const boolKeys = [
          "suspect_headers",
          "headers_suspect",
          "header_inferred",
          "headerless",
          "header_fallback",
          "header_warning",
          "header_issue",
          "headerSuspect",
          "headerInferred",
          "headersSuspect",
          "headerFallback",
        ];
        boolKeys.forEach((key) => {
          const value = obj[key];
          if (value === true) {
            if (likelySpreadsheet) {
              addMessage(HEADER_WARNING_DEFAULT);
            }
          } else if (typeof value === "string" && /suspect|inferred|fallback|unknown/i.test(value)) {
            addMessage(HEADER_WARNING_DEFAULT);
          }
        });

        const statusCandidates = [
          obj.header_status,
          obj.headerStatus,
          obj.header_quality,
          obj.headerQuality,
          obj.header_confidence_label,
        ];
        statusCandidates.forEach((status) => {
          if (typeof status === "string" && /suspect|inferred|fallback|unknown/i.test(status)) {
            addMessage(HEADER_WARNING_DEFAULT);
          }
        });

        const confidence = obj.header_confidence;
        if (typeof confidence === "number" && confidence < 0.6) {
          addMessage(HEADER_WARNING_DEFAULT);
        }

        const arrays = [
          obj.header_warnings,
          obj.warnings,
          obj.ingestion_warnings,
          obj.ingestion_errors,
          obj.messages,
        ];
        arrays.forEach((list) => {
          if (!Array.isArray(list)) return;
          list.forEach((item) => {
            if (!item) return;
            if (typeof item === "string" && /header/i.test(item)) {
              addMessage(item);
            } else if (typeof item === "object") {
              const text = item.message || item.detail || item.reason || item.text;
              if (text && /header/i.test(text)) {
                addMessage(text);
              }
            }
          });
        });
      });

      if (!messages.length && !likelySpreadsheet) {
        return messages;
      }
      return messages;
    }

    function isTriggerBoundary(char) {
      if (!char) return true;
      return /\s|[\(\)\[\]\{\},.;:!?]/.test(char);
    }

    function findActiveMention(text, cursor) {
      if (cursor == null) return null;
      const slice = text.slice(0, cursor);
      const candidates = [];

      const lastAt = slice.lastIndexOf("@");
      if (lastAt >= 0 && isTriggerBoundary(slice[lastAt - 1])) {
        const query = text.slice(lastAt + 1, cursor);
        if (!query.includes(" ") && !query.includes("\n") && !query.includes("\t")) {
          candidates.push({
            type: "vendor",
            trigger: "@",
            start: lastAt,
            cursor,
            query,
            replaceStart: lastAt,
          });
        }
      }

      const lastHash = slice.lastIndexOf("#");
      if (lastHash >= 0 && isTriggerBoundary(slice[lastHash - 1])) {
        const query = text.slice(lastHash + 1, cursor);
        if (!query.includes(" ") && !query.includes("\n") && !query.includes("\t")) {
          candidates.push({
            type: "product",
            trigger: "#",
            start: lastHash,
            cursor,
            query,
            replaceStart: lastHash,
          });
        }
      }

      const lowerSlice = slice.toLowerCase();
      const slashTrigger = "/product";
      const lastSlash = lowerSlice.lastIndexOf(slashTrigger);
      if (lastSlash >= 0 && isTriggerBoundary(slice[lastSlash - 1])) {
        const rawQuery = text.slice(lastSlash + slashTrigger.length, cursor);
        if (!rawQuery.includes("\n")) {
          const trimmedLeading = rawQuery.replace(/^[\s]+/, "");
          const consumedWhitespace = rawQuery.length - trimmedLeading.length;
          candidates.push({
            type: "product",
            trigger: "/product",
            start: lastSlash,
            cursor,
            query: trimmedLeading,
            replaceStart: lastSlash,
            consumedWhitespace,
          });
        }
      }

      if (!candidates.length) {
        return null;
      }
      return candidates.reduce((latest, candidate) => {
        if (!latest) return candidate;
        return candidate.start > latest.start ? candidate : latest;
      }, null);
    }

    const DIAGNOSTIC_KEYWORDS = [
      "connected",
      "connection",
      "backend",
      "database",
      "diagnostic",
      "diagnostics",
      "are you up",
      "are you online",
      "system status",
      "system health",
      "health check",
      "status",
      "ping",
    ];

    const SUMMARY_KEYWORDS = [
      "what products",
      "which products",
      "what's in",
      "what is in",
      "what is inside",
      "what are in",
      "what are these",
      "what are the products",
      "what are the items",
      "products mentioned",
      "mentioned here",
      "what is this sheet",
      "what's this sheet",
      "summary",
      "summarize",
      "summarise",
      "what's their price",
      "what are their prices",
      "what's the price",
      "what is the price",
      "what quantity",
      "what quantities",
      "what's listed",
      "list the products",
      "list products",
      "list items",
    ];

    const HELP_KEYWORDS = [
      "what is ai normalization",
      "ai normalization",
      "how do i re-ingest",
      "how do i reingest",
      "re-ingest",
      "reingest",
      "help topic",
      "faq",
      "prefer llm",
      "prefer_llm",
      "related document",
      "related documents",
      "template download",
      "enabling openai",
      "enable openai",
    ];

    function detectIntent({ query, hasAttachments }) {
      const normalized = (query || "").toLowerCase();
      if (normalized && HELP_KEYWORDS.some((phrase) => normalized.includes(phrase))) {
        return "help";
      }
      if (normalized && DIAGNOSTIC_KEYWORDS.some((phrase) => normalized.includes(phrase))) {
        return "diagnostics";
      }
      if (
        hasAttachments &&
        (!normalized || SUMMARY_KEYWORDS.some((phrase) => normalized.includes(phrase)))
      ) {
        return "document_summary";
      }
      return "best_price";
    }

    function AttachmentPill({ attachment, onRemove }) {
      return React.createElement(
        "div",
        { className: "attachment-pill" },
        attachment.preview &&
          React.createElement("img", {
            src: attachment.preview,
            alt: attachment.file.name,
          }),
        React.createElement(
          "div",
          null,
          React.createElement(
            "strong",
            { style: { display: "block", fontSize: "13px" } },
            attachment.file.name
          ),
          React.createElement(
            "span",
            { style: { fontSize: "12px", color: "rgba(148,163,184,0.75)" } },
            `${(attachment.file.size / 1024).toFixed(1)} KB`
          )
        ),
        React.createElement(
          "button",
          {
            type: "button",
            className: "remove",
            onClick: () => onRemove(attachment.id),
            title: "Remove attachment",
          },
          "×"
        )
      );
    }

    function ProgressMessage({ message }) {
      return React.createElement(
        "div",
        { className: "message-bubble" },
        React.createElement(
          "div",
          { className: "message-metadata" },
          React.createElement(
            "span",
            { className: "inline-badge" },
            "Running tools"
          ),
          React.createElement("span", null, formatDate(message.timestamp))
        ),
        React.createElement("div", null, message.text || "Working…"),
        React.createElement(
          "div",
          { className: "stepper" },
          message.steps.map((step) =>
            React.createElement(
              "div",
              { key: step.id, className: "step", "data-status": step.status },
              step.label
            )
          )
        ),
        message.documents && message.documents.length
          ? React.createElement(
              "div",
              { className: "bundle-footer", style: { marginTop: "12px" } },
              message.documents.map((doc) =>
                React.createElement(
                  "span",
                  { key: doc.id, className: "doc-chip" },
                  doc.file_name,
                  " • ",
                  doc.status
                )
              )
            )
          : null
      );
    }

    function OfferBundle({ bundle }) {
      const specList = [];
      if (bundle.product.model_number) {
        specList.push(`Model ${bundle.product.model_number}`);
      }
      if (bundle.product.upc) {
        specList.push(`UPC ${bundle.product.upc}`);
      }
      if (bundle.product.match_source) {
        specList.push(`Matched via ${bundle.product.match_source}`);
      }

      return React.createElement(
        "div",
        { className: "offer-card" },
        React.createElement(
          "div",
          { className: "offer-header" },
          bundle.product.image_url
            ? React.createElement("img", {
                src: bundle.product.image_url,
                alt: bundle.product.canonical_name,
              })
            : React.createElement("div", {
                style: {
                  width: "126px",
                  height: "126px",
                  borderRadius: "12px",
                  background: "rgba(15,23,42,0.75)",
                  border: "1px solid rgba(148,163,184,0.25)",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  fontSize: "12px",
                  color: "rgba(148,163,184,0.68)",
                  textTransform: "uppercase",
                  letterSpacing: "0.08em",
                },
                children: "No Photo",
              }),
          React.createElement(
            "div",
            { className: "offer-title" },
            React.createElement("h3", null, bundle.product.canonical_name),
            specList.length
              ? React.createElement(
                  "ul",
                  null,
                  specList.map((item, idx) => React.createElement("li", { key: idx }, item))
                )
              : null
          )
        ),
        bundle.best_offer
          ? React.createElement(
              "div",
              { className: "best-offer" },
              React.createElement(
                "div",
                { className: "offer-row" },
                React.createElement(
                  "span",
                  { style: { fontSize: "15px", fontWeight: 600 } },
                  formatCurrency(bundle.best_offer.price, bundle.best_offer.currency)
                ),
                React.createElement(
                  "span",
                  null,
                  bundle.best_offer.condition || ""
                )
              ),
              React.createElement(
                "div",
                { className: "offer-row" },
                React.createElement(
                  "span",
                  null,
                  `${bundle.best_offer.vendor.name} • ${formatDate(bundle.best_offer.captured_at)}`
                ),
                React.createElement(
                  "span",
                  null,
                  bundle.best_offer.location ? `Location: ${bundle.best_offer.location}` : ""
                )
              )
            )
          : React.createElement(
              "div",
              { className: "best-offer" },
              React.createElement(
                "span",
                null,
                "No active offers — try uploading a fresh sheet."
              )
            ),
        React.createElement(
          "div",
          { className: "alternate-list" },
          bundle.alternate_offers && bundle.alternate_offers.length
            ? bundle.alternate_offers.map((offer) =>
                React.createElement(
                  "div",
                  { key: offer.id, className: "alternate-item" },
                  React.createElement(
                    "div",
                    { className: "vendor-row" },
                    React.createElement("span", null, formatCurrency(offer.price, offer.currency)),
                    React.createElement("span", null, offer.vendor.name)
                  ),
                  React.createElement(
                    "div",
                    { className: "vendor-row" },
                    React.createElement("span", null, offer.condition || ""),
                    React.createElement("span", null, offer.location || "")
                  ),
                  React.createElement(
                    "div",
                    { className: "vendor-row" },
                    React.createElement("span", null, `Captured ${relativeTime(offer.captured_at)}`),
                    offer.quantity != null
                      ? React.createElement("span", null, `Qty ${offer.quantity}`)
                      : null
                  )
                )
              )
            : React.createElement(
                "div",
                { className: "alternate-item" },
                "No alternate offers within your filters."
              )
        ),
        React.createElement(
          "div",
          { className: "bundle-footer" },
          React.createElement(
            "span",
            { className: "inline-badge" },
            "Source offers:",
            " ",
            bundle.best_offer && bundle.best_offer.source_document ? bundle.best_offer.source_document.file_name : "N/A"
          ),
          bundle.best_offer && bundle.best_offer.source_document
            ? React.createElement(
                "span",
                null,
                `Processed ${relativeTime(bundle.best_offer.source_document.ingest_completed_at)}`
              )
            : null
        )
      );
    }

    function AnswerMessage({ message }) {
      return React.createElement(
        "div",
        { className: "message-bubble" },
        React.createElement(
          "div",
          { className: "message-metadata" },
          React.createElement("span", { className: "inline-badge" }, "Pricebot"),
          React.createElement("span", null, formatDate(message.timestamp))
        ),
        React.createElement(
          "div",
          { style: { display: "grid", gap: "16px" } },
          message.summary
            ? React.createElement("p", null, message.summary)
            : null,
          message.recentProducts && message.recentProducts.length
            ? React.createElement(
                "div",
                { className: "recent-products" },
                React.createElement("p", { className: "recent-products-title" }, "Recently ingested products"),
                React.createElement(
                  "ul",
                  null,
                  message.recentProducts.map((item) => {
                    const primary =
                      item.alias && item.alias.toLowerCase() !== (item.canonical_name || "").toLowerCase()
                        ? `${item.alias} (${item.canonical_name})`
                        : item.canonical_name;
                    const seen = item.last_seen ? ` — seen ${relativeTime(item.last_seen)}` : "";
                    const offerSuffix =
                      item.offer_count && item.offer_count > 0
                        ? ` • ${item.offer_count} offer${item.offer_count === 1 ? "" : "s"}`
                        : "";
                    return React.createElement("li", { key: item.id }, `${primary}${seen}${offerSuffix}`);
                  })
                )
              )
            : null,
          message.bundles.map((bundle) =>
            React.createElement(OfferBundle, { key: bundle.product.id, bundle })
          ),
          message.documents && message.documents.length
            ? React.createElement(
                "div",
                { className: "bundle-footer" },
                message.documents.map((doc) =>
                  React.createElement(
                    "span",
                    { key: doc.id, className: "doc-chip" },
                    `${doc.file_name} • ${doc.status}`
                  )
                )
              )
            : null,
          message.filters
            ? React.createElement(
                "div",
                { className: "bundle-footer" },
                Object.entries(message.filters)
                  .filter(([, value]) => value)
                  .map(([key, value]) =>
                    React.createElement(
                      "span",
                      { key: key, className: "inline-badge" },
                      `${key}: ${value}`
                    )
                  )
              )
            : null
        )
      );
    }

    function HelpMessage({ message }) {
      const metadataChildren = [
        React.createElement("span", { key: "bot", className: "inline-badge" }, "Pricebot"),
        React.createElement("span", { key: "help", className: "inline-badge" }, "Help"),
      ];
      if (message.used_llm) {
        metadataChildren.push(
          React.createElement("span", { key: "llm", className: "inline-badge" }, "LLM assisted")
        );
      }
      metadataChildren.push(
        React.createElement("span", { key: "time" }, formatDate(message.timestamp))
      );

      const sourcesContent =
        message.sources && message.sources.length
          ? React.createElement(
              "div",
              { className: "help-sources" },
              message.sources.map((source, index) =>
                React.createElement(
                  "div",
                  { key: `${source.path}-${source.heading || index}`, className: "help-source" },
                  React.createElement("h4", null, source.heading || "Documentation"),
                  React.createElement("small", null, source.path),
                  source.snippet ? React.createElement("p", null, source.snippet) : null
                )
              )
            )
          : React.createElement(
              "p",
              { style: { margin: 0, fontSize: "13px", color: "rgba(148, 163, 184, 0.8)" } },
              "No specific documentation matched, but you can explore the Help Topics manual."
            );

      return React.createElement(
        "div",
        { className: "message-bubble" },
        React.createElement("div", { className: "message-metadata" }, ...metadataChildren),
        React.createElement(
          "div",
          { className: "help-answer" },
          message.answer
            ? React.createElement("p", null, message.answer)
            : React.createElement("p", null, "No help answer available."),
          sourcesContent
        )
      );
    }

    function TextMessage({ message }) {
      return React.createElement(
        "div",
        { className: `message-bubble ${message.role === "user" ? "message-user" : ""}` },
        React.createElement(
          "div",
          { className: "message-metadata" },
          React.createElement(
            "span",
            { className: "inline-badge" },
            message.role === "user" ? "You" : "Pricebot"
          ),
          React.createElement("span", null, formatDate(message.timestamp))
        ),
        React.createElement("p", { style: { margin: 0 } }, message.content),
        message.attachments && message.attachments.length
          ? React.createElement(
              "div",
              { className: "message-attachments" },
              message.attachments.map((file) =>
                React.createElement(
                  "span",
                  { key: file.name },
                  `${file.name} • ${(file.size / 1024).toFixed(1)} KB`
                )
              )
            )
          : null,
        message.mentions &&
        ((message.mentions.vendors && message.mentions.vendors.length) ||
          (message.mentions.products && message.mentions.products.length))
          ? React.createElement(
              "div",
              { className: "mention-tray", style: { marginTop: "8px" } },
              [
                ...(message.mentions.vendors || []).map((mention) =>
                  React.createElement(
                    "span",
                    { key: `vendor-${mention.id}`, className: "mention-chip", "data-type": "vendor" },
                    `@${mention.label}`
                  )
                ),
                ...(message.mentions.products || []).map((mention) =>
                  React.createElement(
                    "span",
                    {
                      key: `product-${mention.id}`,
                      className: "mention-chip",
                      "data-type": "product",
                    },
                    `#${mention.label}`
                  )
                ),
              ]
            )
          : null
      );
    }

    function EmptyState({ onAction }) {
      return React.createElement(
        "div",
        { className: "empty-state" },
        React.createElement("h2", null, "Welcome to Pricebot"),
        React.createElement(
          "p",
          null,
          "Upload a price sheet or ask for the best offer on any product. Attach a file, tag a vendor with @VendorName, and I will take it from there."
        ),
        React.createElement(
          "button",
          {
            className: "chat-action-btn",
            style: { marginTop: "16px" },
            type: "button",
            onClick: () => onAction("Show best price for iPhone 15 Pro in Miami"),
          },
          "Try a sample question"
        )
      );
    }

    function ChatApp({ config, devMode, environment }) {
      const [messages, setMessages] = useState(() => [
        {
          id: uid("intro"),
          role: "assistant",
          variant: "text",
          content: "Hi! I’m wired into the latest vendor uploads. Drag in spreadsheets, tag a vendor with @name, or just ask for a product – I’ll resolve the catalog and stream back the best offers.",
          timestamp: new Date().toISOString(),
        },
      ]);
      const [composer, setComposer] = useState("");
      const [attachments, setAttachments] = useState([]);
      const [uploadVendor, setUploadVendor] = useState("");
      const [preferLLM, setPreferLLM] = useState(false);
      const [enterSends, setEnterSends] = useState(true);
      const [isSending, setIsSending] = useState(false);
      const [errorBanner, setErrorBanner] = useState(null);
      const [vendorMentions, setVendorMentions] = useState([]);
      const [productMentions, setProductMentions] = useState([]);
      const [mentionContext, setMentionContext] = useState(null);
      const [mentionSuggestions, setMentionSuggestions] = useState([]);
      const [mentionHighlighted, setMentionHighlighted] = useState(0);
      const [pendingVendor, setPendingVendor] = useState(null);
      const dropRef = useRef(null);
      const transcriptRef = useRef(null);
      const composerRef = useRef(null);
      const mentionAbortRef = useRef(null);

      useEffect(() => {
        if (!transcriptRef.current) return;
        transcriptRef.current.scrollTop = transcriptRef.current.scrollHeight;
      }, [messages]);

      useEffect(() => () => {
        attachments.forEach((att) => {
          if (att.preview) URL.revokeObjectURL(att.preview);
        });
      }, [attachments]);

      useEffect(() => {
        try {
          const storedLLM = localStorage.getItem("pricebot.prefer_llm");
          if (storedLLM != null) {
            setPreferLLM(storedLLM === "true");
          }
        } catch (_err) {
          /* noop */
        }
        try {
          const storedEnterSend = localStorage.getItem("pricebot.enter_sends");
          if (storedEnterSend != null) {
            setEnterSends(storedEnterSend !== "false");
          }
        } catch (_err) {
          /* noop */
        }
      }, []);

      useEffect(() => {
        try {
          localStorage.setItem("pricebot.prefer_llm", preferLLM ? "true" : "false");
        } catch (_err) {
          /* noop */
        }
      }, [preferLLM]);

      useEffect(() => {
        try {
          localStorage.setItem("pricebot.enter_sends", enterSends ? "true" : "false");
        } catch (_err) {
          /* noop */
        }
      }, [enterSends]);

      useEffect(() => {
        if (mentionAbortRef.current) {
          mentionAbortRef.current.abort();
          mentionAbortRef.current = null;
        }
        if (!mentionContext) {
          setMentionSuggestions([]);
          setMentionHighlighted(0);
          return;
        }
        const controller = new AbortController();
        mentionAbortRef.current = controller;
        const fetchSuggestions = async () => {
          try {
            let suggestions = [];
            if (mentionContext.type === "vendor") {
              const vendorUrl = `${config.vendors}?q=${encodeURIComponent(
                mentionContext.query.trim()
              )}&limit=6`;
              const response = await fetch(vendorUrl, { signal: controller.signal });
              if (response.ok) {
                const payload = await response.json();
                if (Array.isArray(payload)) {
                  suggestions = payload.map((item) => ({
                    id: item.id,
                    label: item.name,
                    subtitle: null,
                    type: "vendor",
                  }));
                }
              }
            } else if (mentionContext.type === "product") {
              const query = mentionContext.query.trim();
              if (!query) {
                setMentionSuggestions([]);
                setMentionHighlighted(0);
                return;
              }
              const response = await fetch(config.resolve, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                signal: controller.signal,
                body: JSON.stringify({ query, limit: 6, offset: 0 }),
              });
              if (response.ok) {
                const payload = await response.json();
                if (payload && Array.isArray(payload.products)) {
                  suggestions = payload.products.map((product) => ({
                    id: product.id,
                    label: product.canonical_name,
                    subtitle: [product.model_number, product.upc]
                      .filter(Boolean)
                      .join(" • ") || null,
                    type: "product",
                    raw: product,
                  }));
                }
              }
            }
            if (mentionAbortRef.current === controller) {
              setMentionSuggestions(suggestions);
              setMentionHighlighted(0);
            }
          } catch (error) {
            if (error.name === "AbortError") {
              return;
            }
            console.error("Failed to load mention suggestions", error);
            if (mentionAbortRef.current === controller) {
              setMentionSuggestions([]);
            }
          }
        };
        fetchSuggestions();
        return () => {
          controller.abort();
        };
      }, [mentionContext, config.resolve, config.vendors]);

      function updateProgress(messageId, stepId, status, text) {
        setMessages((prev) =>
          prev.map((msg) => {
            if (msg.id !== messageId) return msg;
            const nextSteps = msg.steps.map((step) =>
              step.id === stepId ? { ...step, status } : step
            );
            return { ...msg, steps: nextSteps, text: text || msg.text };
          })
        );
      }

      function setProgressDocuments(messageId, documents) {
        setMessages((prev) =>
          prev.map((msg) =>
            msg.id === messageId ? { ...msg, documents } : msg
          )
        );
      }

      async function resolveVendorId(name) {
        const trimmed = name.trim();
        if (!trimmed) return null;
        const response = await fetch(`${config.vendors}?q=${encodeURIComponent(trimmed)}&limit=5`);
        if (!response.ok) {
          throw new Error("Failed to search vendors");
        }
        const data = await response.json();
        if (!Array.isArray(data) || !data.length) {
          throw new Error(`Vendor “${trimmed}” not found`);
        }
        const match = data.find((vendor) => vendor.name.toLowerCase() === trimmed.toLowerCase());
        return (match || data[0]).id;
      }

      async function uploadFiles(files, vendorName, progressId, preferLLMEnabled = false) {
        if (!files.length) return [];
        updateProgress(progressId, "upload", "active", "Uploading documents…");
        const form = new FormData();
        files.forEach((item) => {
          form.append("files", item.file, item.file.name);
        });
        form.append("vendor_name", vendorName);
        if (preferLLMEnabled) {
          form.append("prefer_llm", "true");
        }
        const response = await fetch(config.upload, { method: "POST", body: form });
        if (!response.ok) {
          throw new Error(`Upload failed: ${response.status}`);
        }
        const payload = await response.json();
        const documentIds = [];
        const summaries = [];
        if (payload.document_id) {
          documentIds.push(payload.document_id);
          summaries.push({
            id: payload.document_id,
            file_name: payload.filename,
            status: "processing",
          });
        }
        if (Array.isArray(payload.processed)) {
          payload.processed.forEach((doc) => {
            if (doc.document_id) {
              documentIds.push(doc.document_id);
              summaries.push({
                id: doc.document_id,
                file_name: doc.filename || doc.original_name || "uploaded.xlsx",
                status: "processing",
              });
            }
          });
        }
        updateProgress(progressId, "upload", "done", "Documents uploaded – waiting for ingestion…");
        setProgressDocuments(progressId, summaries);
        return documentIds;
      }

      async function pollDocuments(documentIds, progressId) {
        if (!documentIds.length) return [];
        const resolved = [];
        for (const docId of documentIds) {
          let statusPayload = null;
          for (let attempt = 0; attempt < 15; attempt += 1) {
            const response = await fetch(`${config.document}/${docId}`);
            if (!response.ok) break;
            statusPayload = await response.json();
            if (!statusPayload || !statusPayload.status) break;
            if (["processed", "processed_with_warnings", "failed"].includes(statusPayload.status)) {
              break;
            }
            await new Promise((resolve) => setTimeout(resolve, 1500));
          }
          if (statusPayload) {
            resolved.push(statusPayload);
          }
        }
        setProgressDocuments(
          progressId,
          resolved.map((doc) => ({
            id: doc.id,
            file_name: doc.file_name,
            status: doc.status,
          }))
        );
        return resolved;
      }

      function handleFiles(selectedFiles) {
        const additions = Array.from(selectedFiles).map((file) => {
          const isImage = file.type.startsWith("image/");
          return {
            id: uid("file"),
            file,
            preview: isImage ? URL.createObjectURL(file) : null,
          };
        });
        setAttachments((prev) => [...prev, ...additions]);
        if (!uploadVendor && vendorMentions.length) {
          setUploadVendor(vendorMentions[0].label);
        }
      }

      function applyMentionSelection(option, contextOverride) {
        const baseContext = contextOverride || mentionContext;
        if (!baseContext) {
          return;
        }
        if (mentionAbortRef.current) {
          mentionAbortRef.current.abort();
          mentionAbortRef.current = null;
        }

        const composerValue = composerRef.current ? composerRef.current.value : composer;
        let replaceStart =
          baseContext.replaceStart != null ? baseContext.replaceStart : baseContext.start || 0;
        let cursorPoint =
          baseContext.cursor != null ? baseContext.cursor : baseContext.start || replaceStart;
        if (cursorPoint < replaceStart) {
          cursorPoint = replaceStart;
        }
        if (composerValue) {
          const normalizedValue = composerValue.toLowerCase();
          const expectedToken =
            (baseContext.trigger || "@") + (baseContext.query || "").toLowerCase();
          const currentSlice = normalizedValue.slice(replaceStart, cursorPoint);
          if (baseContext.query && !currentSlice.includes((baseContext.query || "").toLowerCase())) {
            const fallbackIndex = normalizedValue.lastIndexOf(expectedToken);
            if (fallbackIndex >= 0) {
              replaceStart = fallbackIndex;
              cursorPoint = fallbackIndex + expectedToken.length;
            }
          }
          if (cursorPoint > composerValue.length) {
            cursorPoint = composerValue.length;
          }
          if (replaceStart > composerValue.length) {
            replaceStart = composerValue.length;
          }
        }

        const safeContext = {
          replaceStart,
          cursor: cursorPoint,
        };

        let nextCursor = null;
        setComposer((prev) => {
          if (safeContext.replaceStart > prev.length) {
            return prev;
          }
          const before = prev.slice(0, safeContext.replaceStart);
          const after = prev.slice(safeContext.cursor);
          const insertion = option.label;
          const needsSpace = after.length === 0 || !/^[\s]/.test(after);
          nextCursor = before.length + insertion.length + (needsSpace ? 1 : 0);
          return `${before}${insertion}${needsSpace ? " " : ""}${after}`;
        });

        requestAnimationFrame(() => {
          if (composerRef.current && nextCursor != null) {
            composerRef.current.focus();
            composerRef.current.selectionStart = nextCursor;
            composerRef.current.selectionEnd = nextCursor;
          }
        });

        setMentionContext(null);
        setMentionSuggestions([]);
        setMentionHighlighted(0);

        if (option.type === "vendor") {
          setVendorMentions((prev) => {
            if (prev.some((entry) => entry.id === option.id)) {
              return prev;
            }
            return [...prev, { id: option.id, label: option.label }];
          });
          setUploadVendor((prev) => (prev ? prev : option.label));
          setPendingVendor(null);
          setErrorBanner(null);
        } else if (option.type === "product") {
          setProductMentions((prev) => {
            if (prev.some((entry) => entry.id === option.id)) {
              return prev;
            }
            const payload = option.raw
              ? { id: option.id, label: option.label, data: option.raw }
              : { id: option.id, label: option.label };
            return [...prev, payload];
          });
        }
      }

      function removeMention(type, id) {
        if (type === "vendor") {
          setVendorMentions((prev) => {
            const removed = prev.find((entry) => entry.id === id);
            const next = prev.filter((entry) => entry.id !== id);
            if (!removed) {
              return prev;
            }
            setUploadVendor((current) => {
              if (next.length > 0) {
                return next[0].label;
              }
              if (current && current === removed.label) {
                return "";
              }
              return current;
            });
            return next;
          });
          clearPendingVendor();
        } else if (type === "product") {
          setProductMentions((prev) => prev.filter((entry) => entry.id !== id));
        }
      }

      async function recordPendingVendor(rawQuery, contextInfo) {
        const query = (rawQuery || "").trim();
        if (!query) return;
        setPendingVendor((prev) => {
          if (prev && prev.query === query && prev.status === "loading") {
            return prev;
          }
          return {
            query,
            status: "loading",
            suggestions: [],
            context: contextInfo
              ? {
                  replaceStart: contextInfo.replaceStart,
                  cursor: contextInfo.cursor,
                  query: contextInfo.query,
                  trigger: contextInfo.trigger,
                  start: contextInfo.start,
                }
              : null,
          };
        });
        setErrorBanner(`Select a vendor for “${query}” or press Esc to keep typing.`);
        try {
          const response = await fetch(`${config.vendors}?q=${encodeURIComponent(query)}&limit=5`);
          if (!response.ok) {
            throw new Error(`lookup failed with ${response.status}`);
          }
          const payload = await response.json();
          setPendingVendor((prev) => {
            if (!prev || prev.query !== query) {
              return prev;
            }
            return {
              query,
              status: "ready",
              suggestions: Array.isArray(payload) ? payload.slice(0, 5) : [],
              context: prev.context,
            };
          });
        } catch (error) {
          console.error("Pending vendor search failed", error);
          setPendingVendor((prev) => {
            if (!prev || prev.query !== query) {
              return prev;
            }
            return { query, status: "error", suggestions: [], context: prev.context || null };
          });
        }
      }

      function clearPendingVendor(query) {
        setPendingVendor((prev) => {
          if (!prev) return prev;
          if (!query || prev.query === query) {
            return null;
          }
          return prev;
        });
        if (pendingVendor && (!query || pendingVendor.query === query)) {
          setErrorBanner(null);
        }
      }

      function handleComposerChange(event) {
        const { value, selectionStart } = event.target;
        setComposer(value);

        const active = findActiveMention(value, selectionStart);

        if (active) {
          if (!mentionContext || mentionContext.start !== active.start || mentionContext.type !== active.type) {
            setMentionHighlighted(0);
          }
          if (active.type === "vendor") {
            clearPendingVendor();
          }
          setMentionContext(active);
        } else {
          if (mentionContext && mentionContext.type === "vendor" && mentionContext.query.trim()) {
            recordPendingVendor(mentionContext.query, mentionContext);
          }
          setMentionContext(null);
        }

        if (pendingVendor) {
          const needle = `@${pendingVendor.query.toLowerCase()}`;
          const normalized = value.toLowerCase();
          if (!normalized.includes(needle)) {
            clearPendingVendor(pendingVendor.query);
          }
        }
      }

      async function handleSend() {
        const trimmed = composer.trim();
        const intent = detectIntent({ query: trimmed, hasAttachments: attachments.length > 0 });
        const shouldUploadAttachments = attachments.length > 0 && intent !== "diagnostics";
        const activeVendorMention =
          mentionContext && mentionContext.type === "vendor" && mentionContext.query.trim();
        const selectedVendor = vendorMentions.length ? vendorMentions[0] : null;
        const vendorLabelForUploads = selectedVendor ? selectedVendor.label : uploadVendor.trim();

        if (activeVendorMention) {
          await recordPendingVendor(mentionContext.query, mentionContext);
          return;
        }
        if (pendingVendor && pendingVendor.query) {
          setErrorBanner(`Select a vendor for “${pendingVendor.query}” before sending.`);
          if (pendingVendor.status !== "loading") {
            await recordPendingVendor(pendingVendor.query, pendingVendor.context || null);
          }
          return;
        }
        if (!trimmed && !attachments.length) {
          return;
        }
        if (shouldUploadAttachments && !vendorLabelForUploads) {
          setErrorBanner("Select a vendor mention or enter a vendor name for the uploads.");
          if (!selectedVendor && uploadVendor.trim()) {
            await recordPendingVendor(uploadVendor);
          }
          return;
        }
        setErrorBanner(null);
        setIsSending(true);

        const userMessage = {
          id: uid("msg"),
          role: "user",
          variant: "text",
          content: trimmed,
          attachments: attachments.map((item) => ({
            name: item.file.name,
            size: item.file.size,
          })),
          mentions: {
            vendors: vendorMentions.map((entry) => ({ id: entry.id, label: entry.label })),
            products: productMentions.map((entry) => ({ id: entry.id, label: entry.label })),
          },
          timestamp: new Date().toISOString(),
        };
        setMessages((prev) => [...prev, userMessage]);

        const queryForTools =
          productMentions.length > 0
            ? productMentions.map((entry) => entry.data?.canonical_name || entry.label).join(", ")
            : trimmed || "best price";

        const progressId = uid("progress");
        let resolvedDocuments = [];
        let succeeded = false;
        let shouldResetUploads = false;

        const progressSteps = [];
        const uploadStepStatus =
          attachments.length === 0 ? "done" : shouldUploadAttachments ? "pending" : "done";
        const uploadStepLabel =
          preferLLM && shouldUploadAttachments ? "Upload attachments (AI normalization)" : "Upload attachments";
        progressSteps.push({
          id: "upload",
          label: uploadStepLabel,
          status: uploadStepStatus,
        });

        if (intent === "diagnostics") {
          progressSteps.push({ id: "diagnostics", label: "Fetch diagnostics", status: "pending" });
          progressSteps.push({ id: "format", label: "Compose answer", status: "pending" });
        } else if (intent === "document_summary") {
          progressSteps.push({ id: "summarize", label: "Summarize documents", status: "pending" });
          progressSteps.push({ id: "format", label: "Compose answer", status: "pending" });
        } else if (intent === "help") {
          progressSteps.push({ id: "help_lookup", label: "Look up help topics", status: "pending" });
          progressSteps.push({ id: "format", label: "Compose answer", status: "pending" });
        } else {
          progressSteps.push({ id: "resolve", label: "Resolve products", status: "pending" });
          progressSteps.push({ id: "best_price", label: "Fetch best offers", status: "pending" });
          progressSteps.push({ id: "format", label: "Compose answer", status: "pending" });
        }

        const progressText =
          intent === "diagnostics"
            ? "Checking diagnostics…"
            : intent === "document_summary"
            ? "Summarizing documents…"
            : intent === "help"
            ? "Looking up help topics…"
            : "Preparing tools…";

        const progressMessage = {
          id: progressId,
          role: "assistant",
          variant: "progress",
          text: progressText,
          steps: progressSteps,
          documents: [],
          timestamp: new Date().toISOString(),
        };
        setMessages((prev) => [...prev, progressMessage]);

        const hasStep = (stepId) => progressSteps.some((step) => step.id === stepId);

        let vendorId = null;
        let vendorName = null;

        try {
          if (shouldUploadAttachments) {
            const docIds = await uploadFiles(attachments, vendorLabelForUploads, progressId, preferLLM);
            resolvedDocuments = await pollDocuments(docIds, progressId);
            shouldResetUploads = true;
          }

          if (intent === "diagnostics") {
            if (!config.diagnostics) {
              throw new Error("Diagnostics endpoint not configured");
            }
            if (hasStep("diagnostics")) {
              updateProgress(progressId, "diagnostics", "active", "Fetching diagnostics…");
            }
            const response = await fetch(config.diagnostics);
            if (!response.ok) {
              throw new Error(`Diagnostics failed (${response.status})`);
            }
            const payload = await response.json();
            if (hasStep("diagnostics")) {
              updateProgress(progressId, "diagnostics", "done", "Diagnostics fetched.");
            }
            if (hasStep("format")) {
              updateProgress(progressId, "format", "active", "Formatting answer…");
            }
            const countsRaw = payload.counts || payload.db_counts || {};
            const normalizedCounts = {
              vendors: countsRaw.vendors ?? countsRaw.vendor_count ?? 0,
              products: countsRaw.products ?? countsRaw.product_count ?? 0,
              offers: countsRaw.offers ?? countsRaw.offer_count ?? 0,
              documents: countsRaw.documents ?? countsRaw.document_count ?? 0,
            };
            const statusText =
              (payload.health && (payload.health.status || payload.health.state || payload.health.detail)) ||
              payload.health_status ||
              payload.status ||
              null;
            const envLabel =
              (payload.metadata && payload.metadata.environment) ||
              (payload.feature_flags && payload.feature_flags.environment) ||
              environment ||
              null;
            const summaryParts = [];
            if (statusText) {
              const normalizedStatus =
                typeof statusText === "string" && statusText.toLowerCase() === "ok"
                  ? "OK"
                  : String(statusText);
              summaryParts.push(`Backend status: ${normalizedStatus}`);
            }
            const countSummary = Object.entries(normalizedCounts)
              .filter(([, value]) => value != null)
              .map(([key, value]) => `${key}: ${value}`);
            if (countSummary.length) {
              summaryParts.push(countSummary.join(" • "));
            }
            if (envLabel) {
              summaryParts.push(`Environment: ${envLabel}`);
            }
            if (devMode && config.diagnostics_download) {
              summaryParts.push("Use the Download diagnostics button for the full JSON report.");
            }
            const diagnosticsMessage = {
              id: uid("diagnostics"),
              role: "assistant",
              variant: "diagnostics",
              timestamp: new Date().toISOString(),
              summary: summaryParts.length ? summaryParts.join(". ") : "Diagnostics retrieved.",
              health: payload.health || null,
              metadata: payload.metadata || payload.service || {},
              db_counts: normalizedCounts,
              feature_flags: payload.feature_flags || payload.flags || {},
              recent_documents:
                payload.recent_documents || payload.last_documents || payload.documents || [],
              recent_offers:
                payload.recent_offers || payload.last_offers || payload.offers || [],
              ingestion_warnings: payload.ingestion_warnings || [],
            };
            setMessages((prev) => [...prev, diagnosticsMessage]);
            if (hasStep("format")) {
              updateProgress(progressId, "format", "done", "Answer ready.");
            }
            succeeded = true;
            return;
          }

          if (intent === "document_summary") {
            if (hasStep("summarize")) {
              updateProgress(progressId, "summarize", "active", "Summarizing documents…");
            }
            if (!resolvedDocuments.length) {
              if (hasStep("summarize")) {
                updateProgress(progressId, "summarize", "done", "Documents still processing.");
              }
              if (hasStep("format")) {
                updateProgress(progressId, "format", "active", "Formatting answer…");
              }
              const summaryMessage = {
                id: uid("doc-summary"),
                role: "assistant",
                variant: "document_summary",
                timestamp: new Date().toISOString(),
                summary: "Uploads received. Waiting for processing — try again in a minute.",
                entries: [],
                documents: resolvedDocuments.map((doc) => ({
                  id: doc.id,
                  file_name: doc.file_name,
                  file_type: doc.file_type,
                  status: doc.status,
                  metadata: doc && typeof doc.metadata === "object" && doc.metadata !== null ? doc.metadata : {},
                })),
              };
              setMessages((prev) => [...prev, summaryMessage]);
              if (hasStep("format")) {
                updateProgress(progressId, "format", "done", "Answer ready.");
              }
              succeeded = true;
              return;
            }

            const detailPayloads = await Promise.all(
              resolvedDocuments.map(async (doc) => {
                const response = await fetch(`${config.document}/${doc.id}`);
                if (!response.ok) {
                  throw new Error(`Failed to load document ${doc.file_name || doc.id}`);
                }
                return response.json();
              })
            );

            if (hasStep("summarize")) {
              updateProgress(progressId, "summarize", "done", "Documents summarized.");
            }
            if (hasStep("format")) {
              updateProgress(progressId, "format", "active", "Formatting answer…");
            }

            const entries = detailPayloads.map((doc) => {
              const metadata = doc && typeof doc.metadata === "object" && doc.metadata !== null ? doc.metadata : {};
              const offers = Array.isArray(doc.offers)
                ? doc.offers.map((offer) => {
                    const normalized = { ...offer };
                    const source = resolveOfferSource(offer, metadata);
                    if (source) {
                      normalized.source = source;
                    }
                    return normalized;
                  })
                : [];
              return {
                id: doc.id,
                file_name: doc.file_name,
                file_type: doc.file_type,
                status: doc.status,
                offers,
                metadata,
                headerWarnings: extractHeaderWarnings(metadata, doc.file_type),
              };
            });

            const totalOffers = entries.reduce((sum, entry) => sum + entry.offers.length, 0);
            const summary =
              totalOffers > 0
                ? `Found ${totalOffers} offer${totalOffers === 1 ? "" : "s"} across ${
                    entries.length
                  } document${entries.length === 1 ? "" : "s"}.`
                : "Documents processed, but no offers were captured.";

            const summaryMessage = {
              id: uid("doc-summary"),
              role: "assistant",
              variant: "document_summary",
              timestamp: new Date().toISOString(),
              summary,
              entries,
              documents: resolvedDocuments.map((doc) => ({
                id: doc.id,
                file_name: doc.file_name,
                file_type: doc.file_type,
                status: doc.status,
                metadata: doc && typeof doc.metadata === "object" && doc.metadata !== null ? doc.metadata : {},
              })),
            };
            setMessages((prev) => [...prev, summaryMessage]);
            if (hasStep("format")) {
              updateProgress(progressId, "format", "done", "Answer ready.");
            }
            succeeded = true;
            return;
          }

          if (intent === "help") {
            if (!config.help) {
              throw new Error("Help endpoint not configured");
            }
            if (hasStep("help_lookup")) {
              updateProgress(progressId, "help_lookup", "active", "Searching help topics…");
            }
            const helpResponse = await fetch(config.help, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                query: trimmed || "pricebot help",
                limit: 3,
              }),
            });
            if (!helpResponse.ok) {
              throw new Error(`Help lookup failed (${helpResponse.status})`);
            }
            const helpPayload = await helpResponse.json();
            if (hasStep("help_lookup")) {
              updateProgress(progressId, "help_lookup", "done", "Help topics retrieved.");
            }
            if (hasStep("format")) {
              updateProgress(progressId, "format", "active", "Formatting answer…");
            }
            const helpMessage = {
              id: uid("help"),
              role: "assistant",
              variant: "help",
              timestamp: new Date().toISOString(),
              answer: helpPayload.answer || "No help details available.",
              sources: Array.isArray(helpPayload.sources) ? helpPayload.sources : [],
              used_llm: Boolean(helpPayload.used_llm),
            };
            setMessages((prev) => [...prev, helpMessage]);
            if (hasStep("format")) {
              updateProgress(progressId, "format", "done", "Answer ready.");
            }
            succeeded = true;
            return;
          }

          if (hasStep("resolve")) {
            updateProgress(progressId, "resolve", "active", "Resolving product matches…");
          }
          const resolveResponse = await fetch(config.resolve, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              query: queryForTools,
              limit: 5,
              offset: 0,
            }),
          });
          if (!resolveResponse.ok) {
            throw new Error("Product resolver failed");
          }
          const resolvePayload = await resolveResponse.json();
          if (hasStep("resolve")) {
            updateProgress(progressId, "resolve", "done", "Products resolved.");
          }

          if (selectedVendor) {
            vendorName = selectedVendor.label;
            vendorId = selectedVendor.id;
          } else if (uploadVendor.trim()) {
            vendorName = uploadVendor.trim();
            vendorId = await resolveVendorId(uploadVendor.trim());
          }

          if (hasStep("best_price")) {
            updateProgress(progressId, "best_price", "active", "Fetching best offers…");
          }
          const filters = {
            vendor_id: vendorId,
            condition: null,
            location: null,
          };
          const bestPriceResponse = await fetch(config.best_price, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              query: queryForTools,
              limit: 5,
              offset: 0,
              filters,
            }),
          });
          if (!bestPriceResponse.ok) {
            throw new Error(`Best price search failed (${bestPriceResponse.status})`);
          }
          const bestPayload = await bestPriceResponse.json();
          if (hasStep("best_price")) {
            updateProgress(progressId, "best_price", "done", "Offers retrieved.");
          }
          if (hasStep("format")) {
            updateProgress(progressId, "format", "active", "Formatting answer…");
          }

          // Fallback: if no best-price results and we have recent uploads, summarize document offers
          if ((!bestPayload.results || bestPayload.results.length === 0) && resolvedDocuments.length > 0) {
            const detailPayloads = await Promise.all(
              resolvedDocuments.map(async (doc) => {
                const response = await fetch(`${config.document}/${doc.id}`);
                if (!response.ok) {
                  throw new Error(`Failed to load document ${doc.file_name || doc.id}`);
                }
                return response.json();
              })
            );

            const entries = detailPayloads.map((doc) => {
              const metadata = doc && typeof doc.metadata === "object" && doc.metadata !== null ? doc.metadata : {};
              const offers = Array.isArray(doc.offers)
                ? doc.offers.map((offer) => {
                    const normalized = { ...offer };
                    const source = resolveOfferSource(offer, metadata);
                    if (source) normalized.source = source;
                    return normalized;
                  })
                : [];
              return {
                id: doc.id,
                file_name: doc.file_name,
                file_type: doc.file_type,
                status: doc.status,
                offers,
                metadata,
                headerWarnings: extractHeaderWarnings(metadata, doc.file_type),
              };
            });

            const totalOffers = entries.reduce((sum, entry) => sum + entry.offers.length, 0);
            const summary =
              totalOffers > 0
                ? `Found ${totalOffers} offer${totalOffers === 1 ? "" : "s"} across ${entries.length} document${
                    entries.length === 1 ? "" : "s"
                  }.`
                : "Documents processed, but no offers were captured.";

            const summaryMessage = {
              id: uid("doc-summary"),
              role: "assistant",
              variant: "document_summary",
              timestamp: new Date().toISOString(),
              summary,
              entries,
              documents: resolvedDocuments.map((doc) => ({
                id: doc.id,
                file_name: doc.file_name,
                file_type: doc.file_type,
                status: doc.status,
                metadata: doc && typeof doc.metadata === "object" && doc.metadata !== null ? doc.metadata : {},
              })),
            };
            setMessages((prev) => [...prev, summaryMessage]);
            if (hasStep("format")) {
              updateProgress(progressId, "format", "done", "Answer ready.");
            }
            succeeded = true;
            shouldResetUploads = shouldUploadAttachments;
            return;
          }

          const displayFilters = {};
          if (vendorName) {
            displayFilters.vendor = vendorName;
          }
          if (bestPayload.applied_filters) {
            const { condition, location, min_price, max_price, captured_since } = bestPayload.applied_filters;
            if (condition) displayFilters.condition = condition;
            if (location) displayFilters.location = location;
            if (min_price != null) displayFilters.min_price = min_price;
            if (max_price != null) displayFilters.max_price = max_price;
            if (captured_since) displayFilters.captured_since = captured_since;
          }

          const resultCount = Array.isArray(bestPayload.results) ? bestPayload.results.length : 0;
          const hasUploads = resolvedDocuments.length > 0;
          const recentProducts = hasUploads ? [] : (bestPayload.recent_products || []);

          let summaryText;
          if (resultCount) {
            summaryText = `Found ${resultCount} product match${resultCount === 1 ? "" : "es"}.`;
          } else if (hasUploads) {
            summaryText = "No active offers matched. Try the document summary option to review your latest upload.";
          } else if (recentProducts.length) {
            summaryText = "No active offers matched. Recently ingested products you can explore:";
          } else {
            summaryText = "No active offers matched. Upload a fresh sheet or adjust filters.";
          }

          const answerMessage = {
            id: uid("answer"),
            role: "assistant",
            variant: "answer",
            bundles: bestPayload.results || [],
            filters: displayFilters,
            documents: resolvedDocuments.map((doc) => ({
              id: doc.id,
              file_name: doc.file_name,
              status: doc.status,
            })),
            timestamp: new Date().toISOString(),
            summary: summaryText,
            recentProducts,
          };
          if (hasStep("format")) {
            updateProgress(progressId, "format", "done", "Answer ready.");
          }
          setMessages((prev) => [...prev, answerMessage]);
          succeeded = true;
          shouldResetUploads = shouldUploadAttachments;
        } catch (error) {
          console.error(error);
          setMessages((prev) =>
            prev.map((msg) =>
              msg.id === progressId
                ? {
                    ...msg,
                    text: error.message || "Something went wrong",
                    steps: msg.steps.map((step) =>
                      step.status === "done" ? step : { ...step, status: "error" }
                    ),
                  }
                : msg
            )
          );
        } finally {
          setIsSending(false);
          if (succeeded && shouldResetUploads) {
            setAttachments((prev) => {
              prev.forEach((att) => att.preview && URL.revokeObjectURL(att.preview));
              return [];
            });
            setUploadVendor("");
          }
          setComposer("");
        }
      }

      function handleKeyDown(event) {
        const hasSuggestions = mentionContext && mentionSuggestions.length > 0;
        if (mentionContext) {
          if (event.key === "ArrowDown" && hasSuggestions) {
            event.preventDefault();
            setMentionHighlighted((prev) => (prev + 1) % mentionSuggestions.length);
            return;
          }
          if (event.key === "ArrowUp" && hasSuggestions) {
            event.preventDefault();
            setMentionHighlighted((prev) =>
              prev - 1 < 0 ? mentionSuggestions.length - 1 : prev - 1
            );
            return;
          }
          if (event.key === "Tab" && hasSuggestions) {
            event.preventDefault();
            applyMentionSelection(mentionSuggestions[mentionHighlighted]);
            return;
          }
          if (event.key === "Enter" && !event.shiftKey && !event.metaKey && !event.ctrlKey) {
            if (hasSuggestions) {
              event.preventDefault();
              applyMentionSelection(mentionSuggestions[mentionHighlighted]);
              return;
            }
          }
          if (event.key === "Escape") {
            event.preventDefault();
            setMentionContext(null);
            setMentionSuggestions([]);
            setMentionHighlighted(0);
            clearPendingVendor();
            return;
          }
        }

        if (event.key === "Enter") {
          const modifierSend = event.metaKey || event.ctrlKey;
          if (enterSends) {
            if (!event.shiftKey && !modifierSend) {
              event.preventDefault();
              if (!isSending) {
                handleSend();
              }
              return;
            }
            if (modifierSend) {
              event.preventDefault();
              if (!isSending) {
                handleSend();
              }
              return;
            }
          } else if (modifierSend) {
            event.preventDefault();
            if (!isSending) {
              handleSend();
            }
          }
        }
      }

      function onDrop(event) {
        event.preventDefault();
        event.stopPropagation();
        dropRef.current && dropRef.current.classList.remove("drop-target");
        if (event.dataTransfer.files && event.dataTransfer.files.length) {
          handleFiles(event.dataTransfer.files);
        }
      }

      function onDragOver(event) {
        event.preventDefault();
        dropRef.current && dropRef.current.classList.add("drop-target");
      }

      function onDragLeave(event) {
        event.preventDefault();
        dropRef.current && dropRef.current.classList.remove("drop-target");
      }

    const quickActions = useMemo(
      () => [
        { label: "Find best price", type: "prompt", text: "Find best price for iPhone 15 Pro in Miami" },
        { label: "Upload price sheet", type: "prompt", text: "@TechSupplier Uploading SB Technology Pricelist Oct" },
        { label: "Check Samsung foldables", type: "prompt", text: "Show Samsung Galaxy Z Fold 6 offers" },
        { label: "Download template", type: "link", href: config.template_download },
      ],
      [config.template_download]
    );

    const environmentLabel = useMemo(() => {
      if (!environment) {
        return "Live data";
      }
      const normalized = String(environment).toLowerCase();
      if (normalized === "production" || normalized === "prod") {
        return "Live data";
      }
      return `${environment} mode`;
    }, [environment]);

    const showDiagnosticsButton = Boolean(config.diagnostics_download);

    const handleDiagnosticsDownload = () => {
      if (!config.diagnostics_download) return;
      window.open(config.diagnostics_download, "_blank", "noopener");
    };

      return React.createElement(
        "div",
        { className: "chat-shell" },
        React.createElement(
          "section",
          { className: "chat-header" },
          React.createElement(
            "div",
            { className: "chat-header-top" },
            React.createElement(
              "div",
              null,
              React.createElement("h1", null, "Price Intelligence Workspace"),
              React.createElement(
                "p",
                null,
                "Attach vendor artefacts, ask natural questions, and track tool calls live."
              )
            ),
            showDiagnosticsButton
              ? React.createElement(
                  "button",
                  {
                    type: "button",
                    className: "diagnostics-btn",
                    onClick: handleDiagnosticsDownload,
                  },
                  "Download diagnostics"
                )
              : null
          ),
          React.createElement(
            "div",
            { className: "chat-actions" },
            quickActions.map((action) => {
              const handleClick = () => {
                if (action.type === "link" && action.href) {
                  window.open(action.href, "_blank", "noopener");
                  return;
                }
                if (action.type === "prompt" && action.text) {
                  setComposer(action.text);
                }
              };
              return React.createElement(
                "button",
                {
                  key: action.label,
                  type: "button",
                  className: "chat-action-btn",
                  onClick: handleClick,
                  disabled: isSending,
                },
                action.label
              );
            }),
            React.createElement(
              "span",
              { className: "status-pill" },
              environmentLabel
            )
          )
        ),
        React.createElement(
          "section",
          {
            ref: (node) => {
              transcriptRef.current = node;
              dropRef.current = node;
            },
            className: "transcript",
            onDrop,
            onDragOver,
            onDragLeave,
          },
          messages.length <= 1
            ? React.createElement(EmptyState, { onAction: setComposer })
            : null,
          messages.map((message) => {
            if (message.variant === "progress") {
              return React.createElement(ProgressMessage, { key: message.id, message });
            }
            if (message.variant === "answer") {
              return React.createElement(AnswerMessage, { key: message.id, message });
            }
            if (message.variant === "help") {
              return React.createElement(HelpMessage, { key: message.id, message });
            }
            if (message.variant === "document_summary") {
              return React.createElement(DocumentSummaryMessage, { key: message.id, message });
            }
            if (message.variant === "diagnostics") {
              return React.createElement(DiagnosticsMessage, { key: message.id, message });
            }
            return React.createElement(TextMessage, { key: message.id, message });
          })
        ),
        React.createElement(
          "section",
          { className: "composer" },
          errorBanner
            ? React.createElement("div", { className: "error-banner" }, errorBanner)
            : null,
          attachments.length
            ? React.createElement(
                "div",
                { className: "attachment-tray" },
                attachments.map((att) =>
                  React.createElement(AttachmentPill, {
                    key: att.id,
                    attachment: att,
                    onRemove: (id) =>
                      setAttachments((prev) => {
                        const next = prev.filter((item) => item.id !== id);
                        const removed = prev.find((item) => item.id === id);
                        if (removed && removed.preview) {
                          URL.revokeObjectURL(removed.preview);
                        }
                        return next;
                      }),
                  })
                )
              )
            : null,
          attachments.length
            ? React.createElement(
                "label",
                { className: "vendor-input" },
                React.createElement(
                  "span",
                  null,
                  "Vendor name for uploads (extracted from @ mention if present)"
                ),
                React.createElement("input", {
                  type: "text",
                  placeholder: "e.g. Tech Supplier",
                  value: uploadVendor,
                  onChange: (event) => setUploadVendor(event.target.value),
                  disabled: isSending,
                })
              )
            : null,
          vendorMentions.length || productMentions.length
            ? React.createElement(
                "div",
                { className: "mention-tray", role: "group", "aria-label": "Selected mentions" },
                [
                  ...vendorMentions.map((mention) =>
                    React.createElement(
                      "span",
                      { key: `vendor-${mention.id}`, className: "mention-chip", "data-type": "vendor" },
                      `@${mention.label}`,
                      React.createElement(
                        "button",
                        {
                          type: "button",
                          onClick: () => removeMention("vendor", mention.id),
                          "aria-label": `Remove vendor ${mention.label}`,
                        },
                        "×"
                      )
                    )
                  ),
                  ...productMentions.map((mention) =>
                    React.createElement(
                      "span",
                      { key: `product-${mention.id}`, className: "mention-chip", "data-type": "product" },
                      `#${mention.label}`,
                      React.createElement(
                        "button",
                        {
                          type: "button",
                          onClick: () => removeMention("product", mention.id),
                          "aria-label": `Remove product ${mention.label}`,
                        },
                        "×"
                      )
                    )
                  ),
                ]
              )
            : null,
          pendingVendor
            ? React.createElement(
                "div",
                { className: "mention-helper", role: "alert" },
                `Select a vendor for “${pendingVendor.query}”.`,
                pendingVendor.status === "loading"
                  ? " Loading suggestions…"
                  : pendingVendor.suggestions.length
                  ? React.createElement(
                      "div",
                      { className: "mention-tray", style: { marginTop: "6px" } },
                      pendingVendor.suggestions.map((vendor) =>
                        React.createElement(
                          "button",
                          {
                            key: vendor.id,
                            type: "button",
                            className: "control-ghost",
                            onClick: () => {
                              const option = { id: vendor.id, label: vendor.name, type: "vendor" };
                              if (pendingVendor.context) {
                                applyMentionSelection(option, pendingVendor.context);
                              } else {
                                setVendorMentions((prev) => {
                                  if (prev.some((entry) => entry.id === vendor.id)) {
                                    return prev;
                                  }
                                  return [...prev, { id: vendor.id, label: vendor.name }];
                                });
                                setUploadVendor((prev) => (prev ? prev : vendor.name));
                                setErrorBanner(null);
                              }
                              clearPendingVendor(pendingVendor.query);
                            },
                          },
                          vendor.name
                        )
                      )
                    )
                  : " No matches found."
              )
            : null,
          React.createElement("textarea", {
            ref: composerRef,
            placeholder: "Ask anything or drag files here. Use @vendor to scope offers.",
            value: composer,
            onChange: handleComposerChange,
            onKeyDown: handleKeyDown,
            disabled: isSending,
          }),
          mentionContext
            ? React.createElement(
                "div",
                {
                  className: "mention-popover",
                  role: "listbox",
                  "aria-label": mentionContext.type === "vendor" ? "Vendor suggestions" : "Product suggestions",
                  style: {
                    top: (composerRef.current ? composerRef.current.offsetTop : 0) + 6,
                    left: (composerRef.current ? composerRef.current.offsetLeft : 0) + 12,
                  },
                },
                React.createElement(
                  "div",
                  { className: "mention-popover-header" },
                  mentionContext.type === "vendor" ? "Vendors" : "Products"
                ),
                mentionSuggestions.length
                  ? mentionSuggestions.map((option, index) =>
                      React.createElement(
                        "button",
                        {
                          key: option.id,
                          type: "button",
                          className: "mention-option",
                          "data-active": index === mentionHighlighted ? "true" : "false",
                          role: "option",
                          "aria-selected": index === mentionHighlighted,
                          onMouseEnter: () => setMentionHighlighted(index),
                          onMouseDown: (event) => {
                            event.preventDefault();
                            applyMentionSelection(option);
                          },
                        },
                        option.label,
                        option.subtitle ? React.createElement("span", null, option.subtitle) : null
                      )
                    )
                  : React.createElement(
                      "div",
                      {
                        className: "mention-option",
                        role: "presentation",
                        style: { cursor: "default" },
                      },
                      mentionContext.type === "product"
                        ? "Type to search for products"
                        : "Keep typing to refine vendors"
                    )
              )
            : null,
          React.createElement(
            "div",
            { className: "composer-controls" },
            React.createElement("label", { className: "control-ghost" },
              React.createElement("input", {
                type: "file",
                multiple: true,
                hidden: true,
                onChange: (event) => {
                  if (event.target.files) {
                    handleFiles(event.target.files);
                    event.target.value = "";
                  }
                },
                disabled: isSending,
              }),
              "Attach files"
            ),
            React.createElement(
              "label",
              {
                className: "control-ghost toggle-control",
                title: "When enabled, spreadsheet uploads will use the AI fallback parser.",
              },
              React.createElement("input", {
                type: "checkbox",
                checked: preferLLM,
                onChange: (event) => setPreferLLM(event.target.checked),
                disabled: isSending,
              }),
              "Use AI normalization"
            ),
            
            React.createElement(
              "button",
              {
                type: "button",
                className: "control-ghost",
                onClick: () => window.open(config.template_download, "_blank", "noopener"),
                disabled: isSending,
              },
              "Download template"
            ),
            React.createElement("button", {
              type: "button",
              onClick: handleSend,
              disabled: isSending,
            }, isSending ? "Working…" : "Send")
          )
        )
      );
    }

    function DocumentSummaryMessage({ message }) {
      const documents = Array.isArray(message.documents) ? message.documents : [];
      const chipSection =
        documents.length
          ? React.createElement(
              "div",
              { className: "bundle-footer" },
              documents.map((doc) =>
                React.createElement(
                  "span",
                  { key: doc.id, className: "doc-chip" },
                  `${doc.file_name || "Document"} • ${doc.status || "unknown"}`
                )
              )
            )
          : null;

      const entries = Array.isArray(message.entries) ? message.entries : [];
      const headerAlerts = [];
      entries.forEach((entry) => {
        if (!Array.isArray(entry.headerWarnings)) {
          return;
        }
        entry.headerWarnings.forEach((warning) => {
          if (!warning) return;
          const normalized = String(warning).trim();
          if (!normalized) return;
          if (!headerAlerts.some((text) => text.toLowerCase() === normalized.toLowerCase())) {
            headerAlerts.push(normalized);
          }
        });
      });

      const headerBanner =
        headerAlerts.length
          ? React.createElement(
              "div",
              { className: "doc-summary-warning", role: "alert" },
              React.createElement("strong", null, "Check spreadsheet headers"),
              headerAlerts.map((text, idx) => React.createElement("span", { key: idx }, text))
            )
          : null;

      const formatSourceLabel = (value) => {
        if (!value) return null;
        return value
          .split(/[_\s]+/)
          .map((part) => (part ? part.charAt(0).toUpperCase() + part.slice(1) : ""))
          .join(" ")
          .trim();
      };

      const entriesContent =
        entries.length
          ? entries.map((entry) => {
              const offers = Array.isArray(entry.offers) ? entry.offers : [];
              const offerList = offers.length
                ? React.createElement(
                    "ul",
                    { className: "doc-summary-list" },
                    offers.map((offer, index) => {
                      const key = offer.id || `${entry.id}-${index}`;
                      const detailParts = [];
                      if (offer.price != null) {
                        detailParts.push(formatCurrency(offer.price, offer.currency));
                      } else if (offer.currency) {
                        detailParts.push(offer.currency);
                      }
                      if (offer.quantity != null) {
                        detailParts.push(`Qty ${offer.quantity}`);
                      }
                      if (offer.condition) {
                        detailParts.push(offer.condition);
                      }
                      if (offer.location) {
                        detailParts.push(offer.location);
                      }
                      const detailText = detailParts.join(" • ");
                      const rawSource = typeof offer.source === "string" ? offer.source.trim() : "";
                      const normalizedSource = rawSource.toLowerCase();
                      const isLLM = normalizedSource === "llm_extractor" || normalizedSource === "llm";
                      const isHeuristic =
                        normalizedSource === "spreadsheet_heuristic" || normalizedSource === "heuristic";
                      const offerClasses = ["doc-offer-item"];
                      if (isLLM) {
                        offerClasses.push("doc-offer-source-llm");
                      } else if (isHeuristic) {
                        offerClasses.push("doc-offer-source-heuristic");
                      }
                      let friendlySource = null;
                      if (rawSource) {
                        if (isLLM) {
                          friendlySource = "LLM normalized";
                        } else if (isHeuristic) {
                          friendlySource = "Heuristic";
                        } else {
                          friendlySource = formatSourceLabel(rawSource);
                        }
                      }
                      const badgeClass = isLLM
                        ? "doc-offer-badge doc-offer-badge-llm"
                        : isHeuristic
                        ? "doc-offer-badge doc-offer-badge-heuristic"
                        : "doc-offer-badge";
                      return React.createElement(
                        "li",
                        { key, className: offerClasses.join(" ") },
                        React.createElement(
                          "div",
                          { className: "doc-offer-title" },
                          React.createElement("span", null, offer.product_name || "Unknown product"),
                          friendlySource
                            ? React.createElement("span", { className: badgeClass }, friendlySource)
                            : null
                        ),
                        detailText
                          ? React.createElement("span", { className: "doc-offer-details" }, detailText)
                          : null
                      );
                    })
                  )
                : React.createElement(
                    "p",
                    { className: "doc-summary-empty" },
                    entry.status === "processing"
                      ? "Still processing — try again in a moment."
                      : "No offers captured yet."
                  );
              return React.createElement(
                "div",
                { key: entry.id, className: "doc-summary" },
                React.createElement(
                  "div",
                  { className: "doc-summary-header" },
                  React.createElement("strong", null, entry.file_name || "Uploaded document"),
                  entry.status
                    ? React.createElement("span", null, `Status: ${entry.status}`)
                    : null
                ),
                offerList
              );
            })
          : React.createElement(
              "p",
              { className: "doc-summary-empty" },
              "Waiting on document processing — you can retry shortly."
            );

      return React.createElement(
        "div",
        { className: "message-bubble" },
        React.createElement(
          "div",
          { className: "message-metadata" },
          React.createElement("span", { className: "inline-badge" }, "Pricebot"),
          React.createElement("span", null, formatDate(message.timestamp))
        ),
        React.createElement(
          "div",
          { style: { display: "grid", gap: "12px" } },
          message.summary ? React.createElement("p", null, message.summary) : null,
          headerBanner,
          entriesContent,
          chipSection
        )
      );
    }

    function DiagnosticsMessage({ message }) {
      const countsEntries = Object.entries(message.db_counts || {});
      const metadataEntries = Object.entries(message.metadata || {});
      const flagEntries = Object.entries(message.feature_flags || {});
      const recentDocuments = (message.recent_documents || []).slice(0, 5);
      const recentOffers = (message.recent_offers || []).slice(0, 5);
      const ingestionWarnings = message.ingestion_warnings || [];

      const formatValue = (value) => {
        if (value == null) return "—";
        if (typeof value === "object") {
          try {
            return JSON.stringify(value);
          } catch (_err) {
            return String(value);
          }
        }
        return String(value);
      };

      return React.createElement(
        "div",
        { className: "message-bubble" },
        React.createElement(
          "div",
          { className: "message-metadata" },
          React.createElement("span", { className: "inline-badge" }, "Pricebot"),
          React.createElement("span", null, formatDate(message.timestamp))
        ),
        React.createElement(
          "div",
          { style: { display: "grid", gap: "12px" } },
          message.summary ? React.createElement("p", null, message.summary) : null,
          countsEntries.length
            ? React.createElement(
                "div",
                { className: "diagnostics-section" },
                React.createElement("h3", null, "Database counts"),
                React.createElement(
                  "div",
                  { className: "diagnostics-list" },
                  countsEntries.map(([key, value]) =>
                    React.createElement(
                      "span",
                      { key, className: "inline-badge" },
                      `${key}: ${value}`
                    )
                  )
                )
              )
            : null,
          metadataEntries.length
            ? React.createElement(
                "div",
                { className: "diagnostics-section" },
                React.createElement("h3", null, "Service metadata"),
                React.createElement(
                  "div",
                  { className: "diagnostics-inline" },
                  metadataEntries.map(([key, value]) =>
                    React.createElement("span", { key }, `${key}: ${formatValue(value)}`)
                  )
                )
              )
            : null,
          flagEntries.length
            ? React.createElement(
                "div",
                { className: "diagnostics-section" },
                React.createElement("h3", null, "Feature flags"),
                React.createElement(
                  "div",
                  { className: "diagnostics-inline" },
                  flagEntries.map(([key, value]) =>
                    React.createElement(
                      "span",
                      { key },
                      `${key}: ${formatValue(value)}`
                    )
                  )
                )
              )
            : null,
          recentDocuments.length
            ? React.createElement(
                "div",
                { className: "diagnostics-section" },
                React.createElement("h3", null, "Recent documents"),
                React.createElement(
                  "div",
                  { className: "diagnostics-inline" },
                  recentDocuments.map((doc) => {
                    const parts = [
                      doc.file_name || doc.id || "Document",
                      doc.status ? `status: ${doc.status}` : null,
                      doc.offers_count != null ? `offers: ${doc.offers_count}` : null,
                    ].filter(Boolean);
                    return React.createElement("span", { key: doc.id || doc.file_name }, parts.join(" • "));
                  })
                )
              )
            : null,
          recentOffers.length
            ? React.createElement(
                "div",
                { className: "diagnostics-section" },
                React.createElement("h3", null, "Recent offers"),
                React.createElement(
                  "div",
                  { className: "diagnostics-inline" },
                  recentOffers.map((offer, index) => {
                    const key = offer.id || `${offer.vendor || "vendor"}-${index}`;
                    const parts = [
                      offer.product || offer.product_name || "Product",
                      offer.vendor || offer.vendor_name ? `vendor: ${offer.vendor || offer.vendor_name}` : null,
                      offer.price != null
                        ? `price: ${formatCurrency(offer.price, offer.currency)}`
                        : offer.currency
                        ? `currency: ${offer.currency}`
                        : null,
                      offer.captured_at ? `captured ${relativeTime(offer.captured_at)}` : null,
                    ].filter(Boolean);
                    return React.createElement("span", { key }, parts.join(" • "));
                  })
                )
              )
            : null,
          ingestionWarnings.length
            ? React.createElement(
                "div",
                { className: "diagnostics-section" },
                React.createElement("h3", null, "Ingestion warnings"),
                React.createElement(
                  "div",
                  { className: "diagnostics-inline" },
                  ingestionWarnings.map((warning) => {
                    const messages = Array.isArray(warning.messages)
                      ? warning.messages.join(" | ")
                      : String(warning.messages || "");
                    const label = warning.file_name || warning.document_id || "Document";
                    return React.createElement(
                      "span",
                      { key: warning.document_id || label },
                      `${label}: ${messages}`
                    );
                  })
                )
              )
            : null
        )
      );
    }

    const root = document.getElementById("chat-root");
    if (root) {
      const app = React.createElement(ChatApp, { config, devMode, environment });
      ReactDOM.createRoot(root).render(app);
    }
  })();
</script>
{% endblock %}
